<#@ template language="C#"#>
<#@ import namespace="System.CodeDom"#>
<#@ import namespace="System.Collections.Generic"#>
<#@ import namespace="UMLToMVCConverter"#>
<#@ import namespace="UMLToMVCConverter.ExtendedTypes"#>
<#@ import namespace="UMLToMVCConverter.ExtensionMethods"#>
<#@ import namespace="Autofac"#>
<#@ assembly name="System.Core"#>
<#
if(this.codeTypeDeclaration.IsStruct) {
	#>	[ComplexType]
<#
}

#>	public<#

if(this.codeTypeDeclaration.IsAbstract) {
	#> abstract<#
}

#> class <#=this.codeTypeDeclaration.Name#> <#

if(this.codeTypeDeclaration.BaseClassName != null) {
	#>: <#= this.codeTypeDeclaration.BaseClassName#> <#
}

#>{<#

if(this.codeTypeDeclaration.IsClass 
	&& string.IsNullOrWhiteSpace(this.codeTypeDeclaration.BaseClassName)
	&& !this.codeTypeDeclaration.HasKey) {
	#>


		public int ID {get; set;}<#
}

foreach (var cm in this.codeTypeDeclaration.Members) {

	if (cm is CodeTypeDeclaration) {
		var ctd = (ExtendedCodeTypeDeclaration) cm;
		var tmpl = this.componentContext.Resolve<IBasicTypeTextTemplate>();
		string innerClass = tmpl.TransformText(ctd);
		#><#=innerClass.AddNewLines(2).NewSection().NewSection()#><#
	}
	else if (cm is CodeMemberProperty) {
		var cmp = (ExtendedCodeMemberProperty) cm;
		string generics = "";
		ExtendedCodeTypeReference type = (ExtendedCodeTypeReference)cmp.Type;
		#>


		<#
		if (!this.codeTypeDeclaration.HasComplexKey && cmp.IsID) {
			#>[Key]
		<#						
		}
		#>public <#
		if (cmp.Attributes.HasFlag(MemberAttributes.Static)) {
			#>static <#
		}
        if (type.ExtType.IsCollection || cmp.IsVirtual) {
			#>virtual <#
		}
		#><#= type.ExtTypeName + " " + cmp.Name #> { get<#
		if (cmp.IsDerived) {
			#> { throw new NotImplementedException(); } <#
		}
		else {
			#>; <#
		}
		if (cmp.HasSet) {
			#>set; <#
		}
		#>}<#
		if (cmp.HasDefaultValue) {
			#> = <#=cmp.DefaultValueString#>;<#
		}
	}
	else if (cm is CodeMemberMethod) {
		var codeMemberMethod = (CodeMemberMethod) cm;
		string returnTypeName = "void";
		if (codeMemberMethod.ReturnType.BaseType != "System.Void") {
			returnTypeName = ((ExtendedCodeTypeReference)codeMemberMethod.ReturnType).ExtTypeName;
		}
		#>


		public<#
		if (codeMemberMethod.Attributes.HasFlag(MemberAttributes.Static)) {
			#> static<#
		}
		#> <#=returnTypeName#> <#=codeMemberMethod.Name#>(<#
		bool addComma = false;
		foreach (ExtendedCodeParameterDeclarationExpression cp in codeMemberMethod.Parameters) {
			if (addComma) {
			#>,<#
			}
			addComma = true;
			#><#= cp.ExtTypeName + " " + cp.Name#><#
		}
		#>) {
			throw new NotImplementedException();
		}<#
	}
}
#>

	}
<#@ template language="C#"#>
<#@ import namespace="System.CodeDom"#>
<#@ import namespace="System.Collections.Generic"#>
<#@ import namespace="UMLToMVCConverter"#>
<#@ import namespace="UMLToMVCConverter.Domain.Models"#>
<#@ import namespace="UMLToMVCConverter.Common"#>
<#@ import namespace="Autofac"#>
<#@ assembly name="System.Core"#>
	public<#

if(this.type.IsAbstract) {
	#> abstract<#
}

#> class <#=this.type.Name#> <#

if(this.type.BaseClassName != null) {
	#>: <#= this.type.BaseClassName#> <#
}

#>{

<#
if(this.type.IsEnum) {
#>		[DatabaseGenerated(DatabaseGeneratedOption.None)]<#
}
if((this.type.IsClass 
	|| this.type.IsEnum)
	&& string.IsNullOrWhiteSpace(this.type.BaseClassName)
	&& !this.type.HasKey) {
	#>

		public int ID {get; set;}<#
}

foreach (var foreignKey in this.type.ForeignKeys) {
	var type = foreignKey.Value.ExtendedType;
	#>

		public <#= type.Name + " " + foreignKey.Key #> { get; set; }<#
}

foreach (var nestedClass in this.type.NestedClasses) {
	var tmpl = this.componentContext.Resolve<IBasicTypeTextTemplate>();
	string innerClassCode = tmpl.TransformText(nestedClass);
	#><#=innerClassCode.AddNewLines(2).NewSection().NewSection()#><#
}

foreach (var property in this.type.Properties) {
		string generics = "";
		var type = property.ExtendedType;
		#>


		<#
		if (!this.type.HasComplexKey && property.IsID) {
			#>[Key]
		<#						
		}
		#>public <#
		if (property.IsStatic) {
			#>static <#
		}
        if (type.IsCollection || property.IsVirtual) {
			#>virtual <#
		}
		#><#= type.Name + " " + property.Name #> { get<#
		if (property.IsDerived) {
			#> { throw new NotImplementedException(); } <#
		}
		else {
			#>; <#
		}
		if (property.HasSet) {
			#>set; <#
		}
		#>}<#
		if (property.HasDefaultValueString) {
			#> = <#=property.DefaultValueString#>;<#
		}
		if (property.IsReferencingEnumType) {
			#>
		

		[ForeignKey("<#=type.Name#>")]
        public int <#=property.Name#>ID { get; set; }
		<#
		}
}

foreach (var method in this.type.Methods) {
	string returnTypeName = "void";
	if (method.ReturnType.Name != "System.Void") {
		returnTypeName = method.ReturnType.Name;
	}
	#>


		public<#
	if (method.IsStatic) {
		#> static<#
	}
	#> <#=returnTypeName#> <#=method.Name#>(<#
	bool addComma = false;
	foreach (var parameter in method.Parameters) {
		if (addComma) {
		#>,<#
		}
		addComma = true;
		#><#= parameter.ExtTypeName + " " + parameter.Name#><#
	}
		#>) {
			throw new NotImplementedException();
		}<#
}
#>

	}